**SYNC CODE IS THE HIGEST**
**ONLY AFTER THE CALL STACK IS EMPTY THE EVENT LOOP COMES INTO PICTURE, HENCE NORMAL?SYNC FLOW OF EXCUETION IS NOT BLOCK**




libuv -> hanles async code / blocking operation

-> it consist of 4 queues
	
	1) Timer Queue (setTimout, setInterval, callbacks)
	2) I/O queue (file input output)
	3) check queue (setImmediate callbacks)
	4) close queue (close handlers)


-> Other 1 queue is parth of Nodejs
	
	**HIGEST PRIORITY AND WILL BE CHECK ONCE BEFORE THE START OF NEXT QUEUE OF LIBUV**		

	1) MicroTask Queue -> in sub it also consist of 2 queues
	
		- nextTick queue ( handles proxess.nextTick callbacks)
		- promise queue ( handles promises callbacks)
		

	Before Next Event loop cycle each time microtask queue is check 


-> Order of excution of queues


NOTE: Before each callback is start/excute or queue starts , the microtask queue is check first and if there then excuted first then move to the queue in next cycle ( etla k hve 3 setTimout che ema 1st settimeout normal console callback, 2nd timeout nae callback ma microtick che and 3rd settimout normal console callback --> toh hve phela 1st timeout nu console print thase pachi ae pachu check karse k microtaskqueue ma kai che nathi , now move to next setTimeout register its callback then console its log and then nextTick is reigster and now move to next setTimeout but before moveing to it , first check microtask queue yes we have nexttick queue ok excute that and then only move to 3rd setTimout) 

1st -> microTask queue --> 1st nextTick is excuted first and then 2nd Promise is excuted

2nd -> Timer queue

3rd -> I/O queue

4th -> check queue

5th -> close queue

6th -> once again microTask queue is check ( if still callback are there then again the loop start )

next Tick and Promise queues are executed in between each queue and also in between each
callback execution in the timer and check queues




